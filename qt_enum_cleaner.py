'''
The first cleaner works, 
Python script that will clean up .py files generated by pyuic5 and fix common :: enum issues like QtCore.Qt.AlignCenter, QtCore.QtCore.Qt.AlignCenter, etc
to run:  python qt_enum_cleaner.py HelloWorld.py
remember to make a backup of your file before running this script:cp HelloWorld.py HelloWorld_backup.py
for the whole folder cleaner  project structure
your_project/
├── qt_enum_cleaner.py
├── HelloWorld.py
└── subfolderName/
    └── another_ui_file.py
this is the tester code that i had to add to the cleaned file to test the changes:
if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())

Example of correction formats to look for:
self.myLabel.setAlignment(QtCore.Qt.Qt::AlignmentFlag::AlignCenter) is wrong
self.myLabel.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter) is correct

''' 
########improved to clean all files in the folder
# import re     # Import the regular expression module
# import sys    # Import the system module for command-line arguments                           
# enum_cleaner.py
# Save the script in your project directory (or globally if you like).

# python enum_cleaner.py MyPyQtAppFolder
# Or for a single file:

# python enum_cleaner.py HelloWorld.py
#############################################################
import sys        ## this version works and I have to add the if __name__ == "__main__": block to the cleaned file to test the changes
import os
import re
from pathlib import Path

def clean_enum_syntax(code):
    # Step 1: Replace C++ style Qt.Something.Enum with Qt.Something.Enum
    code = re.sub(r'Qt::(\w+)::(\w+)', r'Qt.\1.\2', code)

    # Step 2: Replace Qt.Something with Qt.Something (single colon)
    code = re.sub(r'Qt::(\w+)', r'Qt.\1', code)

    # Step 3: Fix overly repeated prefixes like QtCore.Qt.AlignCenter -> QtCore.Qt.AlignCenter
    code = re.sub(r'((QtCore|QtGui)\.)?(Qt\.)(Qt\.)+', r'QtCore.Qt.', code)

    # Step 4: Fix cases where enums were merged without a dot (AlignCenterAlignMiddle -> AlignCenter.AlignMiddle)
    # Optional: Add your custom patterns here if needed

    return code

'''
# def clean_enum_syntax(code):
#     # Replace Qt.Enum.Value style with Qt.EnumValue
#     code = re.sub(r'Qt::(\w+)::(\w+)', r'Qt.\1\2', code)

#     # Replace Qt.EnumValue with Qt.EnumValue
#     code = re.sub(r'Qt::(\w+)', r'Qt.\1', code)

#     # Remove excessive repeated prefixes like QtCore.Qt.Qt
#     code = re.sub(r'(QtCore\.|QtGui\.)?(QtCore\.|QtGui\.)*Qt\.', 'QtCore.Qt.', code)

#     return code
'''
def process_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as f:
        original = f.read()

    cleaned = clean_enum_syntax(original)

    if original != cleaned:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(cleaned)
        print(f"✅ Cleaned: {file_path}")
    else:
        print(f"✔️ Already clean: {file_path}")

def process_directory(target):
    path = Path(target)
    if path.is_file() and path.suffix == '.py':
        process_file(path)
    elif path.is_dir():
        for file in path.rglob("*.py"):
            process_file(file)
    else:
        print(f"❌ Not a valid .py file or directory: {target}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python enum_cleaner.py <file_or_directory>")
    else:
        process_directory(sys.argv[1])

##############NONE OF THE BELOW WORKS111111111111!!!!!!!!!!!!
'''
Here's an improved version of the qt_enum_cleaner.py script that:
Recursively walks through a folder and its subfolders.
Cleans enum issues like QtCore.Qt.AlignCenter.
Removes redundant QtCore.Qt.QtCore prefixes.
Automatically adds a test runner block to show the window if it finds a class named Ui_MainWindow (you can easily extend this logic later).≈

'''


# import os
# import re
# import sys

# def clean_pyqt_enums(content):
#     # Fix C++-style enums like Qt.AlignCenter
#     content = re.sub(r'\bQt::([A-Za-z_]+)', r'QtCore.Qt.\1', content)

#     # Remove duplicate Qt prefixes like QtCore.Qt.AlignCenter
#     content = re.sub(r'(QtCore\.Qt\.)Qt\.', r'\1', content)
#     content = re.sub(r'(QtCore\.Qt\.)QtCore\.', r'\1', content)

#     return content

# def add_runner_if_main(content):
#     if "class Ui_MainWindow" in content and "if __name__ == '__main__':" not in content:
#         runner_code = '''
# if __name__ == "__main__":
#     import sys
#     from PyQt5.QtWidgets import QApplication, QMainWindow
#     app = QApplication(sys.argv)
#     MainWindow = QMainWindow()
#     ui = Ui_MainWindow()
#     ui.setupUi(MainWindow)
#     MainWindow.show()
#     sys.exit(app.exec_())
# '''
#         content += runner_code
#     return content

# def process_file(filepath):
#     with open(filepath, 'r', encoding='utf-8') as f:
#         content = f.read()

#     cleaned = clean_pyqt_enums(content)
#     cleaned = add_runner_if_main(cleaned)

#     with open(filepath, 'w', encoding='utf-8') as f:
#         f.write(cleaned)
#     print(f"✔ Cleaned: {filepath}")

# def clean_directory_recursively(root_folder):
#     for foldername, _, filenames in os.walk(root_folder):
#         for filename in filenames:
#             if filename.endswith('.py'):
#                 full_path = os.path.join(foldername, filename)
#                 process_file(full_path)

# if __name__ == "__main__":
#     if len(sys.argv) != 2:
#         print("Usage: python qt_enum_cleaner.py <folder_path>")
#     else:
#         target_folder = sys.argv[1]
#         clean_directory_recursively(target_folder)


############ third version
# 12:04 9 Apr
# import os
# import re

# def clean_pyqt_enums(content):
#     # Replace C++-style enums like Qt::AlignCenter or AlignmentFlag::AlignCenter
#     content = re.sub(r'\b(\w+)::(\w+)', r'QtCore.Qt.\2', content)

#     # Clean up repeated prefixes like QtCore.Qt.Qt.AlignCenter or Qt.Qt.QtCore.Qt
#     content = re.sub(r'(QtCore\.Qt\.)+(QtCore\.|Qt\.)*', r'QtCore.Qt.', content)

#     return content

# def add_runner_if_main(content):
#     if "__name__ == \"__main__\"" in content or "__name__ == '__main__'" in content:
#         return content  # Already has runner block

#     runner_code = '''
# if __name__ == "__main__":
#     import sys
#     from PyQt5.QtWidgets import QApplication, QMainWindow
#     app = QApplication(sys.argv)
#     MainWindow = QMainWindow()
#     ui = Ui_MainWindow()
#     ui.setupUi(MainWindow)
#     MainWindow.show()
#     sys.exit(app.exec_())
# '''
#     return content.strip() + runner_code

# def process_file(filepath):
#     with open(filepath, 'r', encoding='utf-8') as f:
#         original = f.read()

#     cleaned = clean_pyqt_enums(original)
#     cleaned = add_runner_if_main(cleaned)

#     if cleaned != original:
#         with open(filepath, 'w', encoding='utf-8') as f:
#             f.write(cleaned)
#         print(f"✔ Cleaned: {filepath}")
#     else:
#         print(f"— No changes needed: {filepath}")

# def process_folder_recursively(folder):
#     for root, _, files in os.walk(folder):
#         for file in files:
#             if file.endswith('.py'):
#                 process_file(os.path.join(root, file))

# if __name__ == "__main__":
#     folder_path = input("Enter the folder path to clean PyQt enums recursively: ").strip()
#     if os.path.isdir(folder_path):
#         process_folder_recursively(folder_path)
#         print("\n✅ Done.")
#     else:
#         print("❌ Invalid folder path.")
#########the above works and cleans the files in the folder and subfolders
## BELOW IS THE SAME BUT WILL MAKE A BACKUP OF EACH CLEANED CODE IN A SEPARATE FOLDER
# import os
# import shutil
# import re

# # Define a function to backup files before cleaning
# def backup_file(file_path, backup_folder):
#     if not os.path.exists(backup_folder):
#         os.makedirs(backup_folder)
    
#     file_name = os.path.basename(file_path)
#     backup_path = os.path.join(backup_folder, file_name)
    
#     if os.path.exists(backup_path):
#         print(f"Backup for {file_name} already exists.")
#     else:
#         shutil.copy(file_path, backup_path)
#         print(f"Backup of {file_name} created.")

# # Define the function to clean a file
# def clean_file(file_path):
#     with open(file_path, 'r') as f:
#         content = f.read()

#     # Make changes to the content as before (cleaning up the enums)
#     cleaned_content = re.sub(r'QtCore.Qt::AlignmentFlag::AlignCenter', 'QtCore.Qt.AlignmentFlag.AlignCenter', content)
    
#     # Write the cleaned content back to the file
#     with open(file_path, 'w') as f:
#         f.write(cleaned_content)
#     print(f"File cleaned: {file_path}")

# # Function to clean all files in a folder and its subfolders
# def clean_folder(folder_path, backup_folder):
#     for root, dirs, files in os.walk(folder_path):
#         for file in files:
#             if file.endswith('.py'):  # Only clean Python files
#                 file_path = os.path.join(root, file)
                
#                 # Backup the file first
#                 backup_file(file_path, backup_folder)
                
#                 # Clean the file
#                 clean_file(file_path)


# if __name__ == "__main__":
 
#     folder_to_clean = '/path/to/your/folder'  # Change this to the folder you want to clean
#     backup_folder = '/path/to/backup/folder'  # Change this to the backup folder location
#     clean_folder(folder_to_clean, backup_folder)
######################
#### a more generalized fix for the enums
# import os
# import shutil
# import re

# # Define a function to backup files before cleaning
# def backup_file(file_path, backup_folder):
#     if not os.path.exists(backup_folder):
#         os.makedirs(backup_folder)
    
#     file_name = os.path.basename(file_path)
#     backup_path = os.path.join(backup_folder, file_name)
    
#     if os.path.exists(backup_path):
#         print(f"Backup for {file_name} already exists.")
#     else:
#         shutil.copy(file_path, backup_path)
#         print(f"Backup of {file_name} created.")

# # Define the function to clean a file
# def clean_file(file_path):
#     with open(file_path, 'r') as f:
#         content = f.read()

#     # Generalized regex pattern for fixing common enum conflicts
#     # Fixes double "QtCore.Qt" and "::" issues in enum-style references
#     cleaned_content = re.sub(r'(QtCore\.Qt\.){2,}', 'QtCore.Qt.', content)  # Replace multiple "QtCore.Qt" with single
#     cleaned_content = re.sub(r'QtCore\.(QtCore\.)', 'QtCore.', cleaned_content)  # Replace "QtCore.QtCore" with "QtCore"
#     cleaned_content = re.sub(r'::', '.', cleaned_content)  # Replace "::" with "."
    
#     # Write the cleaned content back to the file
#     with open(file_path, 'w') as f:
#         f.write(cleaned_content)
#     print(f"File cleaned: {file_path}")

# # Function to clean all files in a folder and its subfolders
# def clean_folder(folder_path, backup_folder):
#     for root, dirs, files in os.walk(folder_path):
#         for file in files:
#             if file.endswith('.py'):  # Only clean Python files
#                 file_path = os.path.join(root, file)
                
#                 # Backup the file first
#                 backup_file(file_path, backup_folder)
                
#                 # Clean the file
#                 clean_file(file_path)

# if __name__ == '__main__':
#     # Prompt user for the folder to clean and the backup folder
#     folder_to_clean = input("Enter the folder path to clean: ")
#     backup_folder = input("Enter the backup folder path: ")

#     # Ensure the folder paths are valid
#     if not os.path.exists(folder_to_clean):
#         print(f"Error: The folder {folder_to_clean} does not exist.")
#     else:
#         # Clean the folder
#         clean_folder(folder_to_clean, backup_folder)
#         print("Cleaning process completed.")
####################12:36 9 apr 2025
# import os
# import shutil
# import re

# # Define a function to backup files before cleaning
# def backup_file(file_path, backup_folder):
#     if not os.path.exists(backup_folder):
#         os.makedirs(backup_folder)
    
#     file_name = os.path.basename(file_path)
#     backup_path = os.path.join(backup_folder, file_name)
    
#     if os.path.exists(backup_path):
#         print(f"Backup for {file_name} already exists.")
#     else:
#         shutil.copy(file_path, backup_path)
#         print(f"Backup of {file_name} created.")

# # Define the function to clean a file
# def clean_file(file_path):
#     with open(file_path, 'r') as f:
#         content = f.read()

#     # Generalized regex pattern for fixing common enum conflicts
#     # Fixes double "QtCore.Qt" and "::" issues in enum-style references
#     cleaned_content = re.sub(r'(QtCore\.Qt\.){2,}', 'QtCore.Qt.', content)  # Replace multiple "QtCore.Qt" with single
#     cleaned_content = re.sub(r'QtCore\.(QtCore\.)', 'QtCore.', cleaned_content)  # Replace "QtCore.QtCore" with "QtCore"
#     cleaned_content = re.sub(r'::', '.', cleaned_content)  # Replace "::" with "."
    
#     # Handle Qt enums like QtCore.Qt.Qt.AlignmentFlag -> QtCore.Qt.AlignmentFlag
#     cleaned_content = re.sub(r'(QtCore\.Qt\.){2,}(\w+)', r'QtCore.Qt.\2', cleaned_content)

#     # Write the cleaned content back to the file
#     with open(file_path, 'w') as f:
#         f.write(cleaned_content)
#     print(f"File cleaned: {file_path}")

# # Function to clean all files in a folder and its subfolders
# def clean_folder(folder_path, backup_folder):
#     for root, dirs, files in os.walk(folder_path):
#         for file in files:
#             if file.endswith('.py'):  # Only clean Python files
#                 file_path = os.path.join(root, file)
                
#                 # Backup the file first
#                 backup_file(file_path, backup_folder)
                
#                 # Clean the file
#                 clean_file(file_path)

# if __name__ == '__main__':
#     # Prompt user for the folder to clean and the backup folder
#     folder_to_clean = input("Enter the folder path to clean: ")
#     backup_folder = input("Enter the backup folder path: ")

#     # Ensure the folder paths are valid
#     if not os.path.exists(folder_to_clean):
#         print(f"Error: The folder {folder_to_clean} does not exist.")
#     else:
#         # Clean the folder
#         clean_folder(folder_to_clean, backup_folder)
#         print("Cleaning process completed.")
