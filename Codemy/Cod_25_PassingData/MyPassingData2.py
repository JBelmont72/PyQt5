'''
/Users/judsonbelmont/Documents/Shared_Folders/PyQt5/Codemy/Cod_25_PassingData/MyPassingData.py
i am using the .py files generated by pyuic5 from the .ui file created in Qt Designer.
The first program is a copy of the MyPassingData.py file, which is a simple example of passing data between two Python scripts.
In the second  program i am creating a pushbutton

this is a simple example of passing data between two Python scripts.
# This is a template for a PyQt5 application with a main window and a second window.
# The first window allows the user to enter text, which is then passed to the second window.
from Connect2 import Ui_SecondWindow as SecondWindowUI  # This is the generated UI class from the second window
from Connect1 import Ui_MainWindow as MainWindowUI  # This is the generated UI class from the first window
import sys
from PyQt5 import QtWidgets as qtw
from PyQt5 import QtCore as qtc             

What we‚Äôll add: from  ChatGPT https://chatgpt.com/c/683f6685-7500-800f-9d41-d76f34d4c7fb
A QPushButton in the second window labeled "Clear Combo".
When clicked, it will remove the last item added to the comboBox, or clear the entire list (based on your preference‚ÄîI'll do "clear all" for now).
You can also add a QLineEdit to let the user type in an item to remove just that one, if you prefer.
üîß Updated SecondWindow code with a "Clear Combo" button:
Modify your .py file (not the .ui one!) with this:

class SecondWindow(qtw.QMainWindow, SecondWindowUI):
    def __init__(self, main_window):
        super().__init__()
        self.setupUi(self)

        self.main_window = main_window  # Store reference to main window

        # Connect existing combo box change signal
        self.comboBox.currentTextChanged.connect(self.send_text_back)

        # Add a Clear button to reset submitted text
        self.clear_button = qtw.QPushButton("Clear Combo", self)
        self.clear_button.setGeometry(qtc.QRect(140, 210, 181, 40))
        self.clear_button.setFont(qtg.QFont("Arial", 12))
        self.clear_button.clicked.connect(self.clear_combo_box)

    def send_text_back(self, text):
        self.main_window.update_label(text)

    def clear_combo_box(self):
        self.comboBox.clear()  # Clears all items
        self.main_window.update_label("")  # Clear main window label too
üìù Summary of What Changed
We created a QPushButton named clear_button inside the SecondWindow.
The clear_combo_box() method clears the comboBox.
It also tells the main window to clear the label using update_label("").
Would you like an alternate version where you only remove the selected item, or where you remove based on matching text in a QLineEdit?

'''
# import sys
# from PyQt5 import QtWidgets as qtw
# from PyQt5 import QtCore as qtc
# from PyQt5 import QtGui as qtg
# from Connect1 import Ui_MainWindow as MainWindowUI  # This is the generated UI class from the first window
# from Connect2 import Ui_SecondWindow as SecondWindowUI  # This is the generated UI class from the second window

# # Main application window (First Window)
# class MainWindow(qtw.QMainWindow, MainWindowUI):
#     def __init__(self):
#         super().__init__()
#         # self.ui = MainWindowUI()
#         self.setupUi(self)  # Properly apply the generated UI to this QMainWindow instance

#         # Connect button signals to their slots
#         self.Open.clicked.connect(self.open_second_window)
#         self.Submit.clicked.connect(self.submit_to_second_window)

#         # Create second window instance
#         self.second_window = SecondWindow(self)  # Pass reference to main window

#     def open_second_window(self):
#         self.second_window.show()

#     def submit_to_second_window(self):
#         text = self.textEdit.toPlainText()
#         self.second_window.comboBox.addItem(text)  # Submit text to comboBox in second window

#     def update_label(self, text):
#         self.lineEdit.setText(text)  # Update lineEdit in first window from second window


# # Second application window
# class SecondWindow(qtw.QMainWindow, SecondWindowUI):
#     # This class inherits from QMainWindow and the generated Ui_SecondWindow class.
#     def __init__(self, main_window):
#         super().__init__()
#         # self.ui = SecondWindowUI()
#         self.setupUi(self)

#         self.main_window = main_window  # Store reference to main window

#         # Add a signal for text change in combo box to update the main window's label
#         self.comboBox.currentTextChanged.connect(self.send_text_back)

#     def send_text_back(self, text):
#         # When combo box changes, update the main window's label or line edit
#         self.main_window.update_label(text)


# if __name__ == '__main__':
#     app = qtw.QApplication(sys.argv)
#     window = MainWindow()
#     window.setWindowTitle('Main Window')
#     window.show()
#     sys.exit(app.exec_())



import sys
from PyQt5 import QtWidgets as qtw
from PyQt5 import QtCore as qtc
from PyQt5 import QtGui as qtg
from Connect1 import Ui_MainWindow as MainWindowUI  # This is the generated UI class from the first window
from Connect2 import Ui_SecondWindow as SecondWindowUI  # This is the generated UI class from the second window
## imported from: 
# from PyQt5 import QtCore, QtGui, QtWidgets
# class Ui_MainWindow(object):
#     def setupUi(self, MainWindow):
# Main application window (First Window)
class MainWindow(qtw.QMainWindow, MainWindowUI):    #multiple inheritance
    def __init__(self):
        super().__init__()
        # self.ui = MainWindowUI()
        self.setupUi(self)  # Properly apply the generated UI to this QMainWindow instance
        self.textEdit.setPlaceholderText("Enter your text here")
        # Connect button signals to their slots
        self.Open.clicked.connect(self.open_second_window)
        self.Submit.clicked.connect(self.submit_to_second_window)

        # Create second window instance
        self.second_window = SecondWindow(self)  # Pass reference to main window

    def open_second_window(self):
        self.second_window.show()

    def submit_to_second_window(self):
        text = self.textEdit.toPlainText()
        self.second_window.comboBox.addItem(text)  # Submit text to comboBox in second window

    def update_label(self, text):
        self.lineEdit.setText(text)  # Update lineEdit in first window from second window


# Second application window this does not have the 'clearButton' as does the SecondWindow class below(but this does work as well)
# class SecondWindow(qtw.QMainWindow, SecondWindowUI):
#     # This class inherits from QMainWindow and the generated Ui_SecondWindow class.
#     def __init__(self, main_window):
#         super().__init__()
#         # self.ui = SecondWindowUI()
#         self.setupUi(self)

#         self.main_window = main_window  # Store reference to main window

#         # Add a signal for text change in combo box to update the main window's label
#         self.comboBox.currentTextChanged.connect(self.send_text_back)

#     def send_text_back(self, text):
#         # When combo box changes, update the main window's label or line edit
#         self.main_window.update_label(text)

## the Alternative to creating the 'SecondWindow' and passing multiple inheritance from QMainWindow and SecondWIndowUI is
## to call the SecondWindow from a pushbutton etc in the MainWindow with a function like:
## def open_window(self):
##      self.window = QtWidgets.QMainwindow()
##      self.ui =UiSecondWindow()
##      self.window.show()
class SecondWindow(qtw.QMainWindow, SecondWindowUI):
    def __init__(self, main_window):
        super().__init__()
        self.setupUi(self)

        self.main_window = main_window  # Store reference to main window

        # Connect existing combo box change signal
        self.comboBox.currentTextChanged.connect(self.send_text_back)

        # Add a Clear button to reset submitted text
        self.clear_button = qtw.QPushButton("Clear Combo", self)
        self.clear_button.setGeometry(qtc.QRect(140, 210, 181, 40))
        self.clear_button.setFont(qtg.QFont("Arial", 12))
        self.clear_button.clicked.connect(self.clear_combo_box)

    def send_text_back(self, text):
        self.main_window.update_label(text)

    # def clear_combo_box(self):
    #     self.comboBox.clear()  # Clears all items
    #     self.main_window.update_label("")  # Clear main window label too
    def clear_combo_box(self):## this opens the COnfirmation_Box with functioality
        confirm_dialog = ConfirmationBox(self)
        result = confirm_dialog.exec_()

        if result == qtw.QMessageBox.Yes:
            self.comboBox.clear()
            self.main_window.update_label("")
            # self.main_window.textEdit.setText('Enter your new text')
            # self.main_window.textEdit.setText('Enter your new text')
#    def clear_combo_box(self):  ## this isbare bones to open the COnfirmationBox without functionality
#         confirm_dialog=ConfirmationBox(self)
#         confirm_dialog.exec_()
         
class ConfirmationBox(qtw.QMessageBox):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Confirm Clear")
        self.setText("Are you sure you want to clear the combo box?")
        self.setStandardButtons(qtw.QMessageBox.Yes | qtw.QMessageBox.No)
        self.setDefaultButton(qtw.QMessageBox.No)

if __name__ == '__main__':
    app = qtw.QApplication(sys.argv)
    window = MainWindow()
    window.setWindowTitle('Main Window')
    window.show()
    sys.exit(app.exec_())
    
    
    
    
    
    